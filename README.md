# Лабораторная работа 2

#### Задача

_На плоскости заданы двумя координатами прямоугольники, затем на вход подаются координаты точек. Необходимо за
наименьшее время отвечать, скольким прямоугольникам принадлежит данная точка._

#### Решение

В рамках лабораторной работы было проведено сравнение трех алгоритмов: наивного (brute-force), на "карте" и при помощи
персистентного дерева отрезков. Некоторые из этих алгоритмов требуют препроцессинга, первый же не требует.

## Наивный

**O(0) + O(NM)**

Наивный алгоритм предлагает для каждой новой точки проверять каждый прямоугольник и математически определять,
принадлежит ли ему точка. Данный алгоритм очень прост в реализации и при малом количестве прямоугольников вполне
приемлем, имея сложность O(NM), где N - количество прямоугольников, M - количество точек.

## Алгоритм на карте

**O(N^3) * O(1)**

### Сжатие координат

Алгоритм предполагает сжатие координат, после которого все значения по X и Y отражают только относительное расположение
прямоугольников. Такое сжатие предполагает сортировку координат за O(NlogN), а затем сопоставление сжатых координат
координатам прямоугольников - бинарным поиском позиции в отсортированном массиве (O(logN)).

### Препроцессинг

После того, как координаты сжаты и прямоугольники переведены в новую систему координат, мы можем "построить карту":
заполнить массив N*M (где N - количество уникальных координат по оси у, M - количество уникальных координат по оси х),
для каждого прямоугольника прибавляя 1 каждому элементу массива, принадлежащему прямоугольнику. Так, заполнение карты
имеет сложность O(N**3).

### Запросы

В результате такого препроцессинга ответ на запрос для любой точки происходит за O(1) (обращение к элементу двумерного
массива), однако стоит учесть, что перед ответом точка приводится к сжатой системе координат бинарным поиском (O(logN)).

## Алгоритм на персистентном дереве отрезков

**O(NlogM) * O(logM)**

### Сжатие координат

Алгоритм, так же как и предыдущий, предполагает сжатие координат (для этого используются те же функции).

### Препроцессинг

После того, как координаты сжаты и прямоугольники переведены в новую систему координат, выполняем несколько действий:

1. Разбиваем наши прямоугольники на "события": "открытие" прямоугольника и "закрытие"; событие привязано к координате по
   х и открывает/закрывает прямоугольник на отрезке [y1, y2). Требуется также отсортировать события по х.
2. Строим персистентное дерево отрезков на основе сжатых координат по у; изначально существует лишь дерево в точке х =
   0, в котором нет прямоугольников.
3. Проходимся по всем событиям, изменяя наше "нулевое" дерево: создаем копии узлов, которые имеют пересечения с
   изменяемым отрезком; очевидно, что корневой узел также будет скопирован. Новые корневые узлы будем хранить в словаре
   в формате {"координата по х": <корень дерева после данного ивента>}.

Общая сложность такого препроцессинга составит O(NlogM) - построение N деревьев отрезков.

### Запросы

После такого препроцессинга ответ на запрос будет заключаться в приведении точки к сжатым координатам посредством
бинарного поиска, а затем поиске в словаре корня по ключу х, в найденном дереве узла на отрезке [у, у].

Таким образом, ответ на запрос осуществится приблизительно за O(logN) (поиск в дереве).

## Время работы

_Сырые данные можно посмотреть в файле lab2_measures.txt._

**Особенности тестов**

- Замеры времени работы были произведены отдельно для препроцессинга и ответа на запрос для последних двух алгоритмов.
- Во всех тестах используется набор из 1000 точек, использована генерация, при которой прямоугольники оказываются
  вложенными друг в друга.
- Время было зафиксировано в секундах.

![img.png](img.png)

![img_1.png](img_1.png)

На основании приведенных графиков можно заметить, что алгоритм на карте не демонстрирует сложность O(N^3), несмотря на то, что
она очевидно присутствует в коде. Данное обстоятельство максимально обескураживает меня, так как данный код прошел
контест и на случайно сгенерированных тестах совпадал с результатами наивного поиска и дерева.

Я могу предположить, что такой результат получается либо в результате некорректного измерения времени, либо
особенностями языка Python, многие встроенные функции которого реализованы при помощи компилируемых языков (а именно,
C++). Таким образом, дерево, большая часть функций для которого реализована с нуля на Python, уступает в
производительности карте, которая оказывается быстрее благодаря возможностям языка.

_Более точное выяснение причин некорректности графиков будет здесь._

## Выводы

**Наивный алгоритм** очень хорош для задач, в которых не требуется отвечать на большое количество запросов, обгоняя в этих
условиях алгоритм на карте и алгоритм на дереве.

В то же время, оставаясь интуитивно понятным, **алгоритм на карте** демонстрирует лучшую производительность в условиях
небольшого количества прямоугольников и большого количества точек, однако кубический рост сложности препроцессинга при
увеличении количества прямоугольников заставляет его быть даже менее выгодным в таких условиях, чем наивный алгоритм.

Алгоритм на **персистентном дереве отрезков** иллюстрирует максимально красивую идею, однако оказался очень сложным для
понимания и, конечно, имеет очень высокую сложность по памяти, из-за которой иногда может быть даже менее выгодным, чем
оба предыдущих варианта. Несмотря на эти минусы, по сложности данный алгоритм ощутимо лучше алгоритма на карте и brute-force.